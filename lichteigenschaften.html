<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Licht</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="lichteigenschaften_files/libs/clipboard/clipboard.min.js"></script>
<script src="lichteigenschaften_files/libs/quarto-html/quarto.js"></script>
<script src="lichteigenschaften_files/libs/quarto-html/popper.min.js"></script>
<script src="lichteigenschaften_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="lichteigenschaften_files/libs/quarto-html/anchor.min.js"></script>
<link href="lichteigenschaften_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="lichteigenschaften_files/libs/quarto-html/quarto-syntax-highlighting-2f5df379a58b258e96c21c0638c20c03.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="lichteigenschaften_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="lichteigenschaften_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="lichteigenschaften_files/libs/bootstrap/bootstrap-c0367b04c37547644fece4185067e4a7.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Licht</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Liebe Schülerinnen und Schüler,</p>
<p>heute beschäftigen wir uns mit einem faszinierenden Thema der Physik: der Optik und speziell mit der Lichtausbreitung. Holt eure Arbeitsblätter heraus und folgt mir aufmerksam, denn ihr werdet gleich wichtige Begriffe eintragen müssen.</p>
<p>Zunächst schauen wir uns an, woher das Licht überhaupt kommt. In der Physik unterscheiden wir zwischen zwei großen Kategorien: <strong>Lichtquellen</strong> und <strong>beleuchtete Körper</strong>. Genau, die ersten Lückentexte sind <strong>Lichtquellen</strong> und <strong>beleuchtete Körper</strong> - tragt das bitte ein. <strong>Lichtquellen</strong> und <strong>beleuchtete Körper.</strong> Da kommen diese beiden Begriffe rein.</p>
<p>Ihr fragt euch vielleicht: Warum machen wir überhaupt diese Unterscheidung? Das ist ein typisches Beispiel für die Arbeitsweise der Physik. Wir schaffen Ordnung in der komplexen Welt um uns herum, indem wir Dinge systematisch kategorisieren. Diese Einteilung in Lichtquellen und beleuchtete Körper ist ein Modell – eine Vereinfachung, die uns hilft, die Realität zu verstehen. Natürlich ist die Welt nicht immer so eindeutig, wie unsere Kategorien es suggerieren. Aber diese Systematik wird uns später sehr nützlich sein, wenn wir Lichtverläufe zeichnen und verstehen wollen, wie Licht von einem Ort zum anderen gelangt. Ohne solche Modelle und Vereinfachungen wäre die Physik viel schwerer zu verstehen.</p>
<p>Was sind denn nun Lichtquellen? Das sind <strong>Körper, die Licht aussenden</strong>. Sie produzieren ihr eigenes Licht. Beleuchtete Körper hingegen sind <strong>Körper, die das Licht zurückwerfen</strong> – sie leuchten nur, weil sie von anderen Lichtquellen angestrahlt werden. Schreibt also auf: Lichtquellen sind <strong>Körper, die Licht aussenden</strong>. Beleuchtete Körper sind <strong>Körper, die das Licht zurückwerfen</strong>. Die nächsten Lücken sind also unter Lichtquellen: <strong>Körper, die Licht aussenden</strong>. Und unter beleuchtete Körper: <strong>Körper, die das Licht zurückwerfen</strong>.</p>
<p>Wir wissen ja, Quellen sind der Ursprung von etwas. Bei einer Wasserquelle entspringt Wasser, bei einer Informationsquelle bekommt man Informationen. Für Lichtquellen gilt dasselbe: Sie sind der Ursprung des Lichts. In ihnen entsteht das Licht durch verschiedene Prozesse – in der Sonne durch Kernfusion, in einer Glühlampe durch das Erhitzen eines Drahtes, bei einer Kerze durch Verbrennung. Beim Blitz durch eine Spannungsentladung. Das Entscheidende ist: Das Licht kommt von ihnen, sie sind der Startpunkt für die Lichtausbreitung. Beleuchtete Körper sind dagegen nur Zwischenstationen – sie nehmen Licht auf und geben es weiter, aber sie erschaffen kein neues Licht.</p>
<p>Die Lichtquellen können wir weiter unterteilen in natürliche und künstliche Lichtquellen. Bei den <strong>natürlichen Lichtquellen</strong> denken wir zuerst an die <strong>Sonne</strong> – unsere wichtigste Lichtquelle. Aber es gibt noch andere: der <strong>Blitz</strong> während eines Gewitters, die fernen <strong>Sterne</strong> am Himmel und sogar kleine <strong>Glühwürmchen</strong> im Sommer. Tragt jetzt ein: Als natürliche Lichtquellen haben wir die <strong>Sonne</strong>, den <strong>Blitz</strong>, die <strong>Sterne</strong> und <strong>Glühwürmchen</strong>.</p>
<p>Die <strong>künstlichen Lichtquellen</strong> hat der Mensch entwickelt. Die <strong>Glühlampe</strong> wurde erst 1879 erfunden – vorher mussten die Menschen mit anderen Lichtquellen auskommen. Da gab es schon sehr früh die <strong>Kerze</strong>, die bereits 600 vor Christus verwendet wurde. Noch älter sind die <strong>Fackel</strong> und die <strong>Öllampe</strong>. Ergänzt jetzt die künstlichen Lichtquellen: <strong>Glühlampe</strong>, <strong>Kerze</strong>, <strong>Fackel</strong> und <strong>Öllampe</strong>.</p>
<p>Ihr kennt natürlich alle viel mehr künstliche Lichtquellen. Wir sind tagtäglich davon umgeben. Ob Handy’s, PCs oder Fernseher. Alle diese Geräte senden Licht aus. Und was wird beleuchtet? Eben alles was nicht Lichtquelle ist. Alles was um uns herum ist, ob Tisch, Stuhl und so weiter.</p>
<p>Jetzt schauen wir uns Beispiele für beleuchtete Körper an um ein Paar einzutragen: Ein <strong>Tisch</strong> leuchtet nicht von selbst, sondern nur, weil er von einer Lampe angestrahlt wird. Eine <strong>Wand</strong> verhält sich genauso. Und ein sehr bekanntes Beispiel ist der <strong>Mond</strong> – er produziert kein eigenes Licht, sondern reflektiert nur das Sonnenlicht zu uns zurück. Als beleuchtete Körper schreibt ihr auf: <strong>Tisch</strong>, <strong>Wand</strong>, <strong>Mond</strong> - ihr könnt auch noch andere Beispiele ergänzen.</p>
<p>Kommen wir nun zur Ausbreitung des Lichts. Hier gibt es zwei wichtige Eigenschaften, die ihr euch merken müsst:</p>
<p>Erstens: <strong>Licht breitet sich geradlinig und allseitig aus.</strong> Das bedeutet, das Licht bewegt sich in geraden Linien fort und strahlt in alle Richtungen. Schreibt also: <strong>Licht breitet sich geradlinig und allseitig aus.</strong></p>
<p>Was bedeutet das eigentlich? Nun, wenn eine Lichtquelle leuchtet, dann geht das Licht nicht nur in eine Richtung, sondern in alle Richtungen gleichzeitig. Stellt euch eine Kerze vor: Das Licht strahlt nach oben, nach unten, zur Seite – einfach überall hin. Das nennen wir “allseitig”. Und “geradlinig” bedeutet, dass das Licht immer den direkten Weg nimmt, keine Kurven macht, keine Umwege. Deshalb können wir mit einem Lineal eine gerade Linie von einer Lichtquelle zu einem beleuchteten Punkt ziehen – das ist der Weg, den das Licht genommen hat. Diese Eigenschaft erklärt auch, warum wir Schatten bekommen: Wenn ein Gegenstand im Weg steht, kann das Licht nicht um ihn herumbiegen, sondern wird blockiert. So entstehen die scharfen Schatten, die wir kennen.</p>
<p>Zweitens: Licht ist unglaublich schnell. <strong>Licht breitet sich mit einer Geschwindigkeit von 300.000 km/s aus.</strong> Das sind dreihunderttausend Kilometer pro Sekunde! In einer Sekunde könnte das Licht etwa siebeneinhalb Mal um die Erde wandern. Tragt ein: <strong>Licht breitet sich mit einer Geschwindigkeit von 300.000 km/s aus.</strong></p>
<p>Nun schauen wir uns an, wie wir das Licht beschreiben und untersuchen können. Dazu betrachten wir Lichtbündel und Lichtstrahlen.</p>
<p>Ein <strong>Lichtbündel entsteht, wenn Licht durch den Rand einer Öffnung begrenzt wird.</strong> Stellt euch eine Taschenlampe vor – das Licht, das aus der Öffnung kommt, bildet ein Lichtbündel. Schreibt auf: Ein Lichtbündel entsteht, wenn Licht durch den <strong>Rand</strong> einer Öffnung <strong>begrenzt</strong> wird.</p>
<p>Wir wollen auch ein Lichtbündel einzeichnen sowie die Lampe und Lampengehäuse besdchriften. Die Begriffe die uns hier nützen sind Lampe, der Kreis mit dem X drin. Das ist ein Symbol für Lichtquellen. Es ist sehr nützlich zum Zeichnen von Strahlen und Lichtbündeln, da wir wissen, dass das Licht in der Mitte der <strong>Lampe</strong> beginnt. Von da aus zeichnen wir Licht immer als Geraden, weil wir wissen, dass licht sich allseitig und geradlinig ausbreitet. Da der Lichtverlauf durch das <strong>Lampengehäuse</strong> begrenzt wird, müssen wir eigentlich nur zwei Strahlen zeichnen, statt alle möglichen um die Lampe herum. Ja, das Licht wird von der Lampe in alle Richtungen ausgestrahlen, aber nur diejenigen, die durch den <strong>Rand</strong> der <strong>Gehäuse-Öffnung</strong> kommen, müssen wir eigentlich auch wirklich einzeichnen. Diese zwei Strahlen reichen aus, um ein <strong>Lichtbündel</strong> zu zeichen.</p>
<p>Mit allen diesen Begriffen, <strong>Lampe, Lampengehäuse, Rand der Gehäuse-Öffnung, Lichtbündel</strong> eingetragen, ist die Zeichnung des Lichtbündels das im Gehäuse einer Lampe entsteht sehr schön beschrieben</p>
<p>Als nächstes betrachten wir den Lichtstrahl. Erinnert ihr euch aus der Mathematik? Ein Strahl hat nur eine Länge, keine Breite. Es ist ein mathematisches Modell, denn soetwas gibr es in echt gar nicht.</p>
<p>Ein <strong>Lichtstrahl ist ein sehr schmales Lichtbündel.</strong> In der Realität gibt es eigentlich keinen perfekten Lichtstrahl – es ist immer ein Bündel, auch wenn es noch so schmal ist. Ergänzt: <strong>Ein Lichtstrahl ist ein sehr schmales Lichtbündel.</strong></p>
<p>Um das Licht zu untersuchen, verwenden wir verschiedene Hilfsmittel. Dazu Zeichnen wir auch wieder einen Lichtbündel ein, der auf die <strong>Blende</strong> trifft.</p>
<p>Eine Blende ist ein <strong>lichtundurchlässiger</strong> Körper mit einer oder mehreren <strong>Öffnungen</strong>. Sie hilft uns dabei, das Licht zu formen und zu begrenzen. Schreibt auf: Eine Blende ist ein <strong>lichtundurchlässiger</strong> Körper mit einer oder mehreren <strong>Öffnungen</strong>.</p>
<p>Ein Schirm ist ein <strong>heller</strong> Körper, auf dem das Licht „<strong>aufgefangen</strong>” wird. Auf ihm können wir sehen, wo das Licht ankommt und welche Form es hat. Tragt ein: Ein Schirm ist ein <strong>heller</strong> Körper, auf dem das Licht „<strong>aufgefangen</strong>” wird.</p>
<p>Zum Abschluss noch zwei wichtige Punkte, die ihr euch merken sollt:</p>
<p>Erstens: Einen Lichtstrahl gibt es eigentlich nicht – es ist immer ein Lichtbündel. Man nutzt aber Strahlen als <strong>Modell</strong>, um den <strong>Weg</strong> des Lichts zu zeichnen. In unseren Zeichnungen verwenden wir Linien, um zu zeigen, wo das Licht hingeht – das ist eine Vereinfachung, die uns beim Verstehen hilft. Der erste wichtige Hinweis: Einen Lichtstrahl gibt es eigentlich nicht – es ist immer ein Lichtbündel. Man nutzt aber Strahlen als Modell, um den Weg des Lichts zu zeichnen.</p>
<p>Zweitens: Bisher haben wir Lichtbündel gelb ausgemalt – das machen wir nun <strong>nicht</strong> mehr! Ab sofort zeichnen wir sie nur noch als Linien oder ungefärbte Bereiche.</p>
<p>Das war unser Überblick über die Grundlagen der Lichtausbreitung. Diese Begriffe und Konzepte werden uns in den nächsten Stunden begleiten, wenn wir uns mit Spiegeln, Linsen und anderen optischen Phänomenen beschäftigen.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>